error: Failed to parse archive_2025_05_30\monitoring_dashboard_legacy.py:275:144: Expected 'else', found ':'
error: Failed to parse covenant_test.py:1:246: Compound statements are not allowed on the same line as simple statements
error: Failed to parse update_import_check.py:4:8: Simple statements must be separated by newlines or semicolons
--- run_pytest_diagnostic.py
+++ run_pytest_diagnostic.py
@@ -4,29 +4,34 @@
 import sys
 
 # Setup logging to file
-log_file = open('pytest_diagnostic_output.txt', 'w')
+log_file = open("pytest_diagnostic_output.txt", "w")
+
+
 def log(message):
     print(message)
-    log_file.write(message + '\n')
+    log_file.write(message + "\n")
     log_file.flush()
 
+
 log(f"--- Starting pytest diagnostic run from: {os.getcwd()} ---")
 log(f"Python executable running this script: {sys.executable}")
 
 # Define paths carefully
-project_root = r"C:\project-kortana" # Ensure this is correct
+project_root = r"C:\project-kortana"  # Ensure this is correct
 venv_scripts_path = os.path.join(project_root, "venv311", "Scripts")
 # Try to find pytest within the venv first, then fall back to just 'pytest' (if on PATH)
 pytest_exe_candidate1 = os.path.join(venv_scripts_path, "pytest.exe")
-pytest_exe_candidate2 = os.path.join(venv_scripts_path, "pytest") # For non-Windows venv or if .exe is implicit
-pytest_executable = "pytest" # Fallback if full path isn't found or needed
+pytest_exe_candidate2 = os.path.join(
+    venv_scripts_path, "pytest"
+)  # For non-Windows venv or if .exe is implicit
+pytest_executable = "pytest"  # Fallback if full path isn't found or needed
 
 if os.path.exists(pytest_exe_candidate1):
     pytest_executable = pytest_exe_candidate1
 elif os.path.exists(pytest_exe_candidate2):
     pytest_executable = pytest_exe_candidate2
 
-tests_directory_relative = "tests" # Relative to project_root
+tests_directory_relative = "tests"  # Relative to project_root
 tests_directory_absolute = os.path.join(project_root, tests_directory_relative)
 
 log(f"Attempting to use pytest executable: {pytest_executable}")
@@ -34,12 +39,22 @@
 
 # Verify executable and directory before running
 if not os.path.exists(pytest_executable):
-     # Try a simpler check if pytest is on PATH from activated venv
-    if subprocess.run(["where", "pytest"], capture_output=True, text=True, shell=True, cwd=project_root).stdout.strip():
-         log(f"'pytest.exe' not found at specified venv path, but 'pytest' found on PATH. Will attempt to use 'pytest'.")
-         pytest_executable = "pytest" # Rely on PATH
+    # Try a simpler check if pytest is on PATH from activated venv
+    if subprocess.run(
+        ["where", "pytest"],
+        capture_output=True,
+        text=True,
+        shell=True,
+        cwd=project_root,
+    ).stdout.strip():
+        log(
+            f"'pytest.exe' not found at specified venv path, but 'pytest' found on PATH. Will attempt to use 'pytest'."
+        )
+        pytest_executable = "pytest"  # Rely on PATH
     else:
-        log(f"ERROR: Pytest executable not found at {pytest_exe_candidate1} or {pytest_exe_candidate2}, and not found on PATH.")
+        log(
+            f"ERROR: Pytest executable not found at {pytest_exe_candidate1} or {pytest_exe_candidate2}, and not found on PATH."
+        )
         log_file.close()
         sys.exit(1)
 
@@ -48,12 +63,24 @@
     log_file.close()
     sys.exit(1)
 
-command = [pytest_executable, tests_directory_relative, "-v", "-rA"] # -v for verbose, -rA for all output
+command = [
+    pytest_executable,
+    tests_directory_relative,
+    "-v",
+    "-rA",
+]  # -v for verbose, -rA for all output
 log(f"Executing command: {' '.join(command)} from CWD: {project_root}")
 
 try:
     # Execute pytest from the project root directory
-    process = subprocess.run(command, cwd=project_root, capture_output=True, text=True, check=False, shell=False) # shell=False is safer
+    process = subprocess.run(
+        command,
+        cwd=project_root,
+        capture_output=True,
+        text=True,
+        check=False,
+        shell=False,
+    )  # shell=False is safer
 
     print("\n--- Pytest STDOUT ---")
     print(process.stdout if process.stdout.strip() else "<No STDOUT>")
@@ -64,11 +91,16 @@
     print(f"\n--- Pytest Return Code: {process.returncode} ---")
 
 except FileNotFoundError as fnf_error:
-    print(f"CRITICAL ERROR: Pytest command could not be run. FileNotFoundError: {fnf_error}")
-    print(f"Ensure '{pytest_executable}' is correct and on your system PATH if not using full path, and that venv is active if relying on PATH.")
+    print(
+        f"CRITICAL ERROR: Pytest command could not be run. FileNotFoundError: {fnf_error}"
+    )
+    print(
+        f"Ensure '{pytest_executable}' is correct and on your system PATH if not using full path, and that venv is active if relying on PATH."
+    )
 except Exception as e:
     print(f"CRITICAL ERROR: Exception during pytest execution: {e}")
     import traceback
+
     print(traceback.format_exc())
 
 print("--- End of pytest diagnostic run ---")

--- run_pytest_diagnostic_new.py
+++ run_pytest_diagnostic_new.py
@@ -4,29 +4,34 @@
 import sys
 
 # Setup logging to file
-log_file = open('pytest_diagnostic_output.txt', 'w')
+log_file = open("pytest_diagnostic_output.txt", "w")
+
+
 def log(message):
     print(message)
-    log_file.write(message + '\n')
+    log_file.write(message + "\n")
     log_file.flush()
 
+
 log(f"--- Starting pytest diagnostic run from: {os.getcwd()} ---")
 log(f"Python executable running this script: {sys.executable}")
 
 # Define paths carefully
-project_root = r"C:\project-kortana" # Ensure this is correct
+project_root = r"C:\project-kortana"  # Ensure this is correct
 venv_scripts_path = os.path.join(project_root, "venv311", "Scripts")
 # Try to find pytest within the venv first, then fall back to just 'pytest' (if on PATH)
 pytest_exe_candidate1 = os.path.join(venv_scripts_path, "pytest.exe")
-pytest_exe_candidate2 = os.path.join(venv_scripts_path, "pytest") # For non-Windows venv or if .exe is implicit
-pytest_executable = "pytest" # Fallback if full path isn't found or needed
+pytest_exe_candidate2 = os.path.join(
+    venv_scripts_path, "pytest"
+)  # For non-Windows venv or if .exe is implicit
+pytest_executable = "pytest"  # Fallback if full path isn't found or needed
 
 if os.path.exists(pytest_exe_candidate1):
     pytest_executable = pytest_exe_candidate1
 elif os.path.exists(pytest_exe_candidate2):
     pytest_executable = pytest_exe_candidate2
 
-tests_directory_relative = "tests" # Relative to project_root
+tests_directory_relative = "tests"  # Relative to project_root
 tests_directory_absolute = os.path.join(project_root, tests_directory_relative)
 
 log(f"Attempting to use pytest executable: {pytest_executable}")
@@ -34,12 +39,22 @@
 
 # Verify executable and directory before running
 if not os.path.exists(pytest_executable):
-     # Try a simpler check if pytest is on PATH from activated venv
-    if subprocess.run(["where", "pytest"], capture_output=True, text=True, shell=True, cwd=project_root).stdout.strip():
-         log("'pytest.exe' not found at specified venv path, but 'pytest' found on PATH. Will attempt to use 'pytest'.")
-         pytest_executable = "pytest" # Rely on PATH
+    # Try a simpler check if pytest is on PATH from activated venv
+    if subprocess.run(
+        ["where", "pytest"],
+        capture_output=True,
+        text=True,
+        shell=True,
+        cwd=project_root,
+    ).stdout.strip():
+        log(
+            "'pytest.exe' not found at specified venv path, but 'pytest' found on PATH. Will attempt to use 'pytest'."
+        )
+        pytest_executable = "pytest"  # Rely on PATH
     else:
-        log(f"ERROR: Pytest executable not found at {pytest_exe_candidate1} or {pytest_exe_candidate2}, and not found on PATH.")
+        log(
+            f"ERROR: Pytest executable not found at {pytest_exe_candidate1} or {pytest_exe_candidate2}, and not found on PATH."
+        )
         log_file.close()
         sys.exit(1)
 
@@ -48,12 +63,24 @@
     log_file.close()
     sys.exit(1)
 
-command = [pytest_executable, tests_directory_relative, "-v", "-rA"] # -v for verbose, -rA for all output
+command = [
+    pytest_executable,
+    tests_directory_relative,
+    "-v",
+    "-rA",
+]  # -v for verbose, -rA for all output
 log(f"Executing command: {' '.join(command)} from CWD: {project_root}")
 
 try:
     # Execute pytest from the project root directory
-    process = subprocess.run(command, cwd=project_root, capture_output=True, text=True, check=False, shell=False) # shell=False is safer
+    process = subprocess.run(
+        command,
+        cwd=project_root,
+        capture_output=True,
+        text=True,
+        check=False,
+        shell=False,
+    )  # shell=False is safer
 
     log("\n--- Pytest STDOUT ---")
     log(process.stdout if process.stdout.strip() else "<No STDOUT>")
@@ -64,11 +91,16 @@
     log(f"\n--- Pytest Return Code: {process.returncode} ---")
 
 except FileNotFoundError as fnf_error:
-    log(f"CRITICAL ERROR: Pytest command could not be run. FileNotFoundError: {fnf_error}")
-    log(f"Ensure '{pytest_executable}' is correct and on your system PATH if not using full path, and that venv is active if relying on PATH.")
+    log(
+        f"CRITICAL ERROR: Pytest command could not be run. FileNotFoundError: {fnf_error}"
+    )
+    log(
+        f"Ensure '{pytest_executable}' is correct and on your system PATH if not using full path, and that venv is active if relying on PATH."
+    )
 except Exception as e:
     log(f"CRITICAL ERROR: Exception during pytest execution: {e}")
     import traceback
+
     log(traceback.format_exc())
 
 log("--- End of pytest diagnostic run ---")

--- src\kortana\llm_clients\xai_grok_client.py
+++ src\kortana\llm_clients\xai_grok_client.py
@@ -12,6 +12,7 @@
 
 class XAIGrokClient:
     """XAI Grok client implementation"""
+
     def __init__(self, api_key: str, base_url: str = "https://api.x.ai/v1", **kwargs):
         self.api_key = api_key
         self.base_url = base_url

--- src\kortana\migrations\env.py
+++ src\kortana\migrations\env.py
@@ -12,13 +12,15 @@
 
 # Modify sys.path manipulation
 # sys.path.append(os.path.join(os.path.dirname(__file__), "..", "..", "..")) # Remove or comment out
-sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))) # Add this line
+sys.path.insert(
+    0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
+)  # Add this line
 
 from src.kortana.config.settings import settings
 
 # Import models for autogenerate support
 # from kortana.modules.memory_core.models import CoreMemory  # noqa: F401 # Keep this import if present, ensure path is src.kortana.modules... # Remove or comment out the old import
-from src.kortana.modules.memory_core.models import CoreMemory # Add this line
+from src.kortana.modules.memory_core.models import CoreMemory  # Add this line
 from src.kortana.services.database import Base
 
 # this is the Alembic Config object, which provides
@@ -48,7 +50,7 @@
 #     alembic_config_dict["sqlalchemy.url"] = db_url
 
 # New URL configuration for offline mode
-url = settings.ALEMBIC_DATABASE_URL # Add this line
+url = settings.ALEMBIC_DATABASE_URL  # Add this line
 
 # other values from the config, defined by the needs of env.py,
 # can be acquired:
@@ -69,7 +71,7 @@
 
     """
     # url = config.get_main_option("sqlalchemy.url") # Remove or comment out
-    url = settings.ALEMBIC_DATABASE_URL # Add this line
+    url = settings.ALEMBIC_DATABASE_URL  # Add this line
     context.configure(
         url=url,
         target_metadata=target_metadata,
@@ -87,18 +89,19 @@
     with context.begin_transaction():
         context.run_migrations()
 
+
 # Replace run_migrations_online and run_async_migrations with the new sync version
 def run_migrations_online() -> None:
     """Run migrations in 'online' mode."""
     from sqlalchemy import create_engine
+
     connectable = create_engine(settings.ALEMBIC_DATABASE_URL)
 
     with connectable.connect() as connection:
-        context.configure(
-            connection=connection, target_metadata=target_metadata
-        )
+        context.configure(connection=connection, target_metadata=target_metadata)
         context.run_migrations()
 
+
 # async def run_async_migrations() -> None: # Remove or comment out
 #     """In this scenario we need to create an Engine...
 

--- src\kortana\modules\memory_core\models.py
+++ src\kortana\modules\memory_core\models.py
@@ -10,7 +10,9 @@
     title = Column(String(255), nullable=False, index=True)
     content = Column(Text, nullable=False)
     created_at = Column(DateTime(timezone=True), server_default=func.now())
-    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
+    updated_at = Column(
+        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
+    )
 
     def __repr__(self):
         return f"<CoreMemory(id={self.id}, title='{self.title[:30]}...')>"

5 files would be reformatted, 333 files already formatted
